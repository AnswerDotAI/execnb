[
  {
    "objectID": "shell.html",
    "href": "shell.html",
    "title": "shell",
    "section": "",
    "text": "Use CaptureShell to execute the IPython/Jupyter source code.\n\ns = CaptureShell()\n\n\n\n\n\nCaptureShell.run\n\nCaptureShell.run(self: CaptureShell, code: str, stdout=True, stderr=True)\n\nruns code, returning a list of all outputs in Jupyter notebook format\n\n\n\n\ns.run(\"print(1)\")\n\n[{'name': 'stdout', 'output_type': 'stream', 'text': ['1']}]\n\n\nCode can include magics and ! shell commands:\n\ns.run(\"%time 1+1\")\n\n[{'data': {'text/plain': ['2']},\n  'metadata': {},\n  'output_type': 'execute_result',\n  'execution_count': 1},\n {'name': 'stdout',\n  'output_type': 'stream',\n  'text': ['CPU times: user 2 us, sys: 0 ns, total: 2 us',\n   'Wall time: 3.58 us']}]\n\n\nThe result of the last successful execution is stored in result:\n\ns.result\n\n2\n\n\nIf an exception is raised then the exception type, object, and stacktrace are stored in exc:\n\ns.run('raise Exception(\"Oops\")')\ntyp,obj,st = s.exc\ntyp,obj\n\n(Exception, Exception('Oops'))\n\n\n\nprint(st)\n\n---------------------------------------------------------------------------\nException                                 Traceback (most recent call last)\nInput In [1], in <cell line: 1>()\n----> 1 raise Exception(\"Oops\")\n\nException: Oops\n\n\n\n\n\n\nCaptureShell.cell\n\nCaptureShell.cell(self: CaptureShell, cell, stdout=True, stderr=True)\n\nRun cell, skipping if not code, and store outputs back in cell\n\n\n\n\nclean = Path('../tests/clean.ipynb')\nnb = read_nb(clean)\nc = nb.cells[1]\nc\n\njson{ 'cell_type': 'code',  'execution_count': None,  'id': 'b123d6d0',  'idx_': 1,  'metadata': {},  'outputs': [],  'source': 'print(1)\\n2'}\n\n\n\ns.cell(c)\nc.outputs\n\n[{'data': {'text/plain': ['2']},\n  'metadata': {},\n  'output_type': 'execute_result',\n  'execution_count': 2},\n {'name': 'stdout', 'output_type': 'stream', 'text': ['1']}]\n\n\n\n\n\n\nCaptureShell.run_all\n\nCaptureShell.run_all(self: CaptureShell, nb, exc_stop=False)\n\nRun all cells in nb, stopping at first exception if exc_stop\n\n\n\n\nnb.cells[2].outputs\n\n(#0) []\n\n\n\ns.run_all(nb)\nnb.cells[2].outputs\n\n[{'data': {'text/plain': ['<IPython.core.display.Markdown object>'],\n   'text/markdown': [\"This is *bold*. Here's a [link](https://www.fast.ai).\"]},\n  'metadata': {},\n  'output_type': 'execute_result',\n  'execution_count': 5}]\n\n\nWith exc_stop=False (the default), execution continues after exceptions, and exception details are stored into the appropriate cell’s output:\n\nnb.cells[-1].source\n\n'raise Exception(\"Oopsie!\")'\n\n\n\nnb.cells[-1].outputs\n\n[{'ename': \"<class 'Exception'>\",\n  'evalue': 'Oopsie!',\n  'output_type': 'error',\n  'traceback': ['\\x1b[0;31m---------------------------------------------------------------------------\\x1b[0m',\n   '\\x1b[0;31mException\\x1b[0m                                 Traceback (most recent call last)',\n   'Input \\x1b[0;32mIn [1]\\x1b[0m, in \\x1b[0;36m<cell line: 1>\\x1b[0;34m()\\x1b[0m\\n\\x1b[0;32m----> 1\\x1b[0m \\x1b[38;5;28;01mraise\\x1b[39;00m \\x1b[38;5;167;01mException\\x1b[39;00m(\\x1b[38;5;124m\"\\x1b[39m\\x1b[38;5;124mOopsie!\\x1b[39m\\x1b[38;5;124m\"\\x1b[39m)\\n',\n   '\\x1b[0;31mException\\x1b[0m: Oopsie!']}]\n\n\nWith exc_stop=True (the default), exceptions in a cell are raised and no further processing occurs:\n\ntry: s.run_all(nb, exc_stop=True)\nexcept Exception as e: print(f\"got exception: {e}\")\n\ngot exception: Oopsie!\n\n\n\n\n\n\nCaptureShell.execute\n\nCaptureShell.execute(self: CaptureShell, src, dest, exc_stop=False)\n\nExecute notebook from src and save with outputs to `dest\n\n\n\n\ntry:\n    s.execute(clean, 'tmp.ipynb')\n    print(read_nb('tmp.ipynb').cells[1].outputs)\nfinally: Path('tmp.ipynb').unlink()\n\n[{'data': {'text/plain': ['2']}, 'execution_count': 10, 'metadata': {}, 'output_type': 'execute_result'}, {'name': 'stdout', 'output_type': 'stream', 'text': ['1']}]"
  },
  {
    "objectID": "nbio.html",
    "href": "nbio.html",
    "title": "nbio",
    "section": "",
    "text": "A notebook is just a json file.\n\nminimal_fn = Path('../tests/minimal.ipynb')\nminimal_txt = AttrDict(minimal_fn.read_json())\n\nIt contains two sections, the metadata…:\n\nminimal_txt.metadata\n\n{'kernelspec': {'display_name': 'Python 3 (ipykernel)',\n  'language': 'python',\n  'name': 'python3'},\n 'language_info': {'codemirror_mode': {'name': 'ipython', 'version': 3},\n  'file_extension': '.py',\n  'mimetype': 'text/x-python',\n  'name': 'python',\n  'nbconvert_exporter': 'python',\n  'pygments_lexer': 'ipython3',\n  'version': '3.9.7'}}\n\n\n…and, more importantly, the cells:\n\nminimal_txt.cells\n\n[{'cell_type': 'markdown',\n  'metadata': {},\n  'source': ['## A minimal notebook']},\n {'cell_type': 'code',\n  'execution_count': 1,\n  'metadata': {},\n  'outputs': [{'data': {'text/plain': ['2']},\n    'execution_count': 1,\n    'metadata': {},\n    'output_type': 'execute_result'}],\n  'source': ['# Do some arithmetic\\n', '1+1']}]\n\n\nThe second cell here is a code cell, however it contains no outputs, because it hasn’t been executed yet. To execute a notebook, we first need to convert it into a format suitable for nbclient (which expects some dict keys to be available as attrs, and some available as regular dict keys). Normally, nbformat is used for this step, but it’s rather slow and inflexible, so we’ll write our own function based on fastcore’s handy dict2obj, which makes all keys available as both attrs and keys.\n\n\n\n\n\n\nNbCell(idx, cell)\n\ndict subclass that also provides access to keys as attrs\n\n\n\nWe use an AttrDict subclass which has some basic functionality for accessing notebook cells.\n\n\n\n\n\n\ndict2nb(js)\n\nConvert dict js to an AttrDict,\n\n\n\nWe can now convert our JSON into this nbclient-compatible format, which pretty prints the source code of cells in notebooks.\n\nminimal = dict2nb(minimal_txt)\ncell = minimal.cells[1]\ncell\n\njson{ 'cell_type': 'code',  'execution_count': 1,  'idx_': 1,  'metadata': {},  'outputs': [{'data': {'text/plain': ['2']}, 'execution_count': 1, 'metadata': {}, 'output_type': 'execute_result'}],  'source': '# Do some arithmetic\\n1+1'}\n\n\nThe abstract syntax tree of source code cells is available in the parsed_ property:\n\ncell.parsed_(), cell.parsed_()[0].value.op\n\n([<ast.Expr at 0x7f4f64408d90>], <ast.Add at 0x7f4fa04e3040>)\n\n\n\n\n\n\n\n\nread_nb(path)\n\nReturn notebook at path\n\n\n\nThis reads the JSON for the file at path and converts it with dict2nb. For instance:\n\nminimal = read_nb(minimal_fn)\nstr(minimal.cells[0])\n\n\"{'cell_type': 'markdown', 'metadata': {}, 'source': '## A minimal notebook', 'idx_': 0}\""
  },
  {
    "objectID": "nbio.html#writing-a-notebook",
    "href": "nbio.html#writing-a-notebook",
    "title": "nbio",
    "section": "Writing a notebook",
    "text": "Writing a notebook\n\n\n\n\nnb2dict\n\nnb2dict(d, k=None)\n\nConvert parsed notebook to dict\n\n\n\nThis returns the exact same dict as is read from the notebook JSON.\n\nminimal_fn = Path('../tests/minimal.ipynb')\nminimal = read_nb(minimal_fn)\n\nminimal_dict = minimal_fn.read_json()\nassert minimal_dict==nb2dict(minimal)\n\n\n\n\n\nnb2str\n\nnb2str(nb)\n\nConvert nb to a str\n\n\n\nTo save a notebook we first need to convert it to a str:\n\nprint(nb2str(minimal)[:45])\n\n{\n \"cells\": [\n  {\n   \"cell_type\": \"markdown\",\n\n\n\n\n\n\nwrite_nb\n\nwrite_nb(nb, path)\n\nWrite nb to path\n\n\n\nThis returns the exact same string as saved by Jupyter.\n\ntmp = Path('tmp.ipynb')\ntry:\n    minimal_txt = minimal_fn.read_text()\n    write_nb(minimal, tmp)\n    assert minimal_txt==tmp.read_text()\nfinally: tmp.unlink()"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "execnb",
    "section": "",
    "text": "Either:\npip install execnb\nor if you use conda:\nconda install -c fastai execnb\n(You can replace conda with mamba in the line above if you have mamba installed.)"
  },
  {
    "objectID": "index.html#how-to-use",
    "href": "index.html#how-to-use",
    "title": "execnb",
    "section": "How to use",
    "text": "How to use\nUse CaptureShell to run Jupyter code and capture notebook outputs, without running a Jupyter server (or even having it installed):\n\ns = CaptureShell()\ns.run('1+1')\n\n[{'data': {'text/plain': ['2']},\n  'metadata': {},\n  'output_type': 'execute_result',\n  'execution_count': 1}]\n\n\nTo execute a notebook and save it with outputs filled in, use execute:\n\ntry:\n    s.execute('../tests/clean.ipynb', 'tmp.ipynb')\n    print(read_nb('tmp.ipynb').cells[1].outputs)\nfinally: Path('tmp.ipynb').unlink()\n\n[{'data': {'text/plain': ['2']}, 'execution_count': 6, 'metadata': {}, 'output_type': 'execute_result'}, {'name': 'stdout', 'output_type': 'stream', 'text': ['1']}]"
  }
]