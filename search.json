[
  {
    "objectID": "index.html#install",
    "href": "index.html#install",
    "title": "execnb",
    "section": "Install",
    "text": "Install\nEither:\npip install execnb\nor if you use conda:\nconda install -c fastai execnb\n(You can replace conda with mamba in the line above if you have mamba installed.)",
    "crumbs": [
      "execnb"
    ]
  },
  {
    "objectID": "index.html#how-to-use",
    "href": "index.html#how-to-use",
    "title": "execnb",
    "section": "How to use",
    "text": "How to use\nUse CaptureShell to run Jupyter code and capture notebook outputs, without running a Jupyter server (or even having it installed):\n\nfrom execnb.nbio import *\nfrom execnb.shell import *\nfrom fastcore.utils import *\n\n\ns = CaptureShell()\ns.run('1+1')\n\n[{'data': {'text/plain': ['2']},\n  'metadata': {},\n  'output_type': 'execute_result',\n  'execution_count': None}]\n\n\nTo execute a notebook and save it with outputs filled in, use CaptureShell.execute:\n\ntry:\n    s.execute('../tests/clean.ipynb', 'tmp.ipynb')\n    print(read_nb('tmp.ipynb').cells[1].outputs)\nfinally: Path('tmp.ipynb').unlink()\n\n[{'name': 'stdout', 'output_type': 'stream', 'text': ['1\\n']}, {'data': {'text/plain': ['2']}, 'execution_count': None, 'metadata': {}, 'output_type': 'execute_result'}]\n\n\nYou can also execute notebooks from the command line with exec_nb:\n\n!exec_nb --help\n\nusage: exec_nb [-h] [--dest DEST] [--exc_stop] [--inject_code INJECT_CODE]\n               [--inject_path INJECT_PATH] [--inject_idx INJECT_IDX] [--verbose]\n               src\n\nExecute notebook from `src` and save with outputs to `dest`\n\npositional arguments:\n  src                        Notebook path to read from\n\noptions:\n  -h, --help                 show this help message and exit\n  --dest DEST                Notebook path to write to (default: )\n  --exc_stop                 Stop on exceptions? (default: False)\n  --inject_code INJECT_CODE  Code to inject into a cell\n  --inject_path INJECT_PATH  Path to file containing code to inject into a cell\n  --inject_idx INJECT_IDX    Cell to replace with `inject_code` (default: 0)\n  --verbose                  Show stdout/stderr during execution (default:\n                             False)",
    "crumbs": [
      "execnb"
    ]
  },
  {
    "objectID": "shell.html",
    "href": "shell.html",
    "title": "shell",
    "section": "",
    "text": "from fastcore.test import *\nfrom base64 import b64decode\nfrom io import BytesIO\nfrom PIL import Image\n\n\nsource\n\nExecutionResult.__repr__\n\ndef __repr__(\n    \n):\n\nReturn repr(self).\n\nsource\n\n\nExecutionInfo.__repr__\n\ndef __repr__(\n    \n):\n\nReturn repr(self).\n\nsource\n\n\nCaptureShell\n\ndef CaptureShell(\n    path:str | Path=None, mpl_format:str='retina', history:bool=False, timeout:Optional[int]=None\n):\n\nAn enhanced, interactive shell for Python.\n\nsource\n\n\nCaptureShell.run_cell\n\ndef run_cell(\n    raw_cell, # The code (including IPython code such as %magic functions) to run.\n    store_history:bool=False, # If True, the raw and translated cell will be stored in IPython's\nhistory. For user code calling back into IPython's machinery, this\nshould be set to False.\n    silent:bool=False, # If True, avoid side-effects, such as implicit displayhooks and\nand logging.  silent=True forces store_history=False.\n    shell_futures:bool=True, # If True, the code will share future statements with the interactive\nshell. It will both be affected by previous __future__ imports, and\nany __future__ imports in the code will affect the shell. If False,\n__future__ imports are not shared in either direction.\n    cell_id:NoneType=None, # A unique identifier for the cell. This is used in the messaging system\nto match output with execution requests and for tracking cell execution\nhistory across kernel restarts. In notebook contexts, this is typically\na UUID generated by the frontend. If None, the kernel may generate an\ninternal identifier or proceed without cell tracking capabilities.\n    stdout:bool=True, stderr:bool=True, display:bool=True, timeout:NoneType=None, verbose:bool=False\n):\n\nRun a complete IPython cell.\n\ns = CaptureShell(mpl_format='retina')\n\n\ns.run_cell('a=1');\n\n{ 'display_objects': [],\n  'exception': None,\n  'quiet': False,\n  'result': result: None; err: None; info: &lt;cell: a=1; id: None&gt;,\n  'stderr': '',\n  'stdout': ''}\n\n\n\no = s.run_cell('print(a)')\no\n\n{ 'display_objects': [],\n  'exception': None,\n  'quiet': False,\n  'result': result: None; err: None; info: &lt;cell: print(a); id: None&gt;,\n  'stderr': '',\n  'stdout': '1\\n'}\n\n\n\no = s.run_cell('from warnings import warn; warn(\"1\")')\no\n\n{ 'display_objects': [],\n  'exception': None,\n  'quiet': False,\n  'result': result: None; err: None; info: &lt;cell: from warnings import warn; warn(\"1\"); id: None&gt;,\n  'stderr': '&lt;ipython-input-1-a51443ae013a&gt;:1: UserWarning: 1\\n'\n            '  from warnings import warn; warn(\"1\")\\n',\n  'stdout': ''}\n\n\n\no = s.run_cell('1')\no\n\n{ 'display_objects': [],\n  'exception': None,\n  'quiet': False,\n  'result': result: 1; err: None; info: &lt;cell: 1; id: None&gt;,\n  'stderr': '',\n  'stdout': ''}\n\n\n\no = s.run_cell('from IPython.display import Markdown,display; print(0); display(Markdown(\"*2*\")); Markdown(\"*1*\")')\no\n\n{ 'display_objects': [&lt;IPython.utils.capture.RichOutput object&gt;],\n  'exception': None,\n  'quiet': False,\n  'result': result: &lt;IPython.core.display.Markdown object&gt;; err: None; info: &lt;cell: from IPython.display import Markdown,display; print(0); display(Markdown(\"*2*\")); Markdown(\"*1*\"); id: None&gt;,\n  'stderr': '',\n  'stdout': '0\\n'}\n\n\n\no.result.result\n\n1\n\n\n\no.display_objects[0]\n\n2\n\n\n\no = s.run_cell('1;')\no\n\n{ 'display_objects': [],\n  'exception': None,\n  'quiet': True,\n  'result': result: 1; err: None; info: &lt;cell: 1;; id: None&gt;,\n  'stderr': '',\n  'stdout': ''}\n\n\n\no = s.run_cell('import matplotlib.pyplot as plt; plt.plot([1,2,3])')\no\n\n{ 'display_objects': [&lt;IPython.utils.capture.RichOutput object&gt;],\n  'exception': None,\n  'quiet': False,\n  'result': result: [&lt;matplotlib.lines.Line2D object&gt;]; err: None; info: &lt;cell: import matplotlib.pyplot as plt; plt.plot([1,2,3]); id: None&gt;,\n  'stderr': '',\n  'stdout': ''}\n\n\n\no.result.result[0]\n\n\no.display_objects[0]\n\n\n\n\n\n\n\n\n\no = s.run_cell('''\nimport pandas as pd\npd.DataFrame({'A': [1, 2], 'B': [3, 4]})''')\no\n\n{ 'display_objects': [],\n  'exception': None,\n  'quiet': False,\n  'result': result:    A  B\n0  1  3\n1  2  4; err: None; info: &lt;cell: \nimport pandas as pd\npd.DataFrame({'A': [1, 2], 'B': [3, 4]}); id: None&gt;,\n  'stderr': '',\n  'stdout': ''}\n\n\n\no.result.result\n\n\n\n\n\n\n\n\nA\nB\n\n\n\n\n0\n1\n3\n\n\n1\n2\n4\n\n\n\n\n\n\n\n\no = s.run_cell('1/0')\no\n\n{ 'display_objects': [],\n  'exception': ZeroDivisionError('division by zero'),\n  'quiet': False,\n  'result': result: None; err: division by zero; info: &lt;cell: 1/0; id: None&gt;,\n  'stderr': '',\n  'stdout': '\\x1b[31m---------------------------------------------------------------------------\\x1b[39m\\n'\n            '\\x1b[31mZeroDivisionError\\x1b[39m                         '\n            'Traceback (most recent call last)\\n'\n            '\\x1b[36mFile '\n            '\\x1b[39m\\x1b[32m&lt;ipython-input-1-9e1622b385b6&gt;:1\\x1b[39m\\n'\n            '\\x1b[32m----&gt; \\x1b[39m\\x1b[32m1\\x1b[39m '\n            '\\x1b[32;43m1\\x1b[39;49m\\x1b[43m/\\x1b[49m\\x1b[32;43m0\\x1b[39;49m\\n'\n            '\\n'\n            '\\x1b[31mZeroDivisionError\\x1b[39m: division by zero\\n'}\n\n\nTesting errors caught after exec:\n\no = s.run_cell('import time; time.sleep(2)', timeout=1)\ntest_eq(type(o['exception']), TimeoutError)\n\nTesting errors caught before exec:\n\no = s.run_cell('print(', timeout=1)\ntest_eq(isinstance(o['exception'], SyntaxError), True)\no = s.run_cell(\"def foo():\\npass\")\ntest_eq(isinstance(o['exception'], IndentationError), True)\no = s.run_cell(\"if True:\\n\\tpass\\n        pass\")\ntest_eq(isinstance(o['exception'], TabError), True)\n\n\n\nCells / run\n\nsource\n\n\nformat_exc\n\ndef format_exc(\n    e\n):\n\nFormat exception e as a string list\n\nsource\n\n\nNbResult\n\ndef NbResult(\n    args:VAR_POSITIONAL, kwargs:VAR_KEYWORD\n):\n\nBuilt-in mutable sequence.\nIf no argument is given, the constructor creates a new empty list. The argument must be an iterable if specified.\n\nsource\n\n\nCaptureShell.run\n\ndef run(\n    code:str, # Python/IPython code to run\n    stdout:bool=True, # Capture stdout and save as output?\n    stderr:bool=True, # Capture stderr and save as output?\n    timeout:Optional[int]=None, # Shell command will time out after {timeout} seconds\n    verbose:bool=False, # Show stdout/stderr during execution\n):\n\nRun code, returning a list of all outputs in Jupyter notebook format\n\ns = CaptureShell()\n\n\ns.run(\"print(1)\")\n\n[{'name': 'stdout', 'output_type': 'stream', 'text': ['1\\n']}]\n\n\nCode can include magics and ! shell commands:\n\no = s.run(\"%time 1+1\")\no\n\n[{'name': 'stdout',\n  'output_type': 'stream',\n  'text': ['CPU times: user 1 us, sys: 1 us, total: 2 us\\n',\n   'Wall time: 4.05 us\\n']},\n {'data': {'text/plain': ['2']},\n  'metadata': {},\n  'output_type': 'execute_result',\n  'execution_count': None}]\n\n\nThe result of the last successful execution is stored in result:\n\ns.result\n\n2\n\n\nA trailing ; stops the result from being captured:\n\ns.run(\"1+2;\")\n\n[]\n\n\n\no = s.run(\"1/0\")\no\n\n[{'name': 'stdout',\n  'output_type': 'stream',\n  'text': ['\\x1b[31m---------------------------------------------------------------------------\\x1b[39m\\n',\n   '\\x1b[31mZeroDivisionError\\x1b[39m                         Traceback (most recent call last)\\n',\n   '\\x1b[36mFile \\x1b[39m\\x1b[32m&lt;ipython-input-1-9e1622b385b6&gt;:1\\x1b[39m\\n',\n   '\\x1b[32m----&gt; \\x1b[39m\\x1b[32m1\\x1b[39m \\x1b[32;43m1\\x1b[39;49m\\x1b[43m/\\x1b[49m\\x1b[32;43m0\\x1b[39;49m\\n',\n   '\\n',\n   '\\x1b[31mZeroDivisionError\\x1b[39m: division by zero\\n']},\n {'ename': 'ZeroDivisionError',\n  'evalue': 'division by zero',\n  'output_type': 'error',\n  'traceback': ['Traceback (most recent call last):\\n',\n   '  File \"/home/radek/miniconda3/envs/kaggle/lib/python3.11/site-packages/IPython/core/interactiveshell.py\", line 3672, in run_code\\n    exec(code_obj, self.user_global_ns, self.user_ns)\\n',\n   '  File \"&lt;ipython-input-1-9e1622b385b6&gt;\", line 1, in &lt;module&gt;\\n    1/0\\n    ~^~\\n',\n   'ZeroDivisionError: division by zero\\n']}]\n\n\nThis is how IPython formats exceptions internally:\n\nfrom IPython.core.ultratb import VerboseTB\n\n\nwith warnings.catch_warnings():\n    warnings.filterwarnings(\"ignore\", category=DeprecationWarning)\n    formatter = VerboseTB(color_scheme='Linux')\n\n\ntry: f()\nexcept Exception as e:\n    ex = e\n    print(formatter.text(type(e), e, e.__traceback__))\n\n---------------------------------------------------------------------------\nNameError                                 Traceback (most recent call last)\nCell In[35], line 1\n----&gt; 1 try: f()\n      2 except Exception as e:\n      3     ex = e\n\nNameError: name 'f' is not defined\n\n\n\ns.run(\"import time; time.sleep(0.1); print('no timeout')\", timeout=1)\n\n[{'name': 'stdout', 'output_type': 'stream', 'text': ['no timeout\\n']}]\n\n\n\no = s.run(\"import time; time.sleep(1.1)\", timeout=1)\no[0]['text'][:2]\n\n['\\x1b[31m---------------------------------------------------------------------------\\x1b[39m\\n',\n '\\x1b[31mTimeoutError\\x1b[39m                              Traceback (most recent call last)\\n']\n\n\n\no1 = s.run('from IPython.display import Markdown,display; print(0); print(1); display(Markdown(\"*2*\")); Markdown(\"*1*\")')\no1\n\n[{'name': 'stdout', 'output_type': 'stream', 'text': ['0\\n', '1\\n']},\n {'data': {'text/plain': ['&lt;IPython.core.display.Markdown object&gt;'],\n   'text/markdown': ['*2*']},\n  'metadata': {},\n  'output_type': 'display_data'},\n {'data': {'text/plain': ['&lt;IPython.core.display.Markdown object&gt;'],\n   'text/markdown': ['*1*']},\n  'metadata': {},\n  'output_type': 'execute_result',\n  'execution_count': None}]\n\n\n\nsource\n\n\nCaptureShell.run_async\n\ndef run_async(\n    code:str, # Python/IPython code to run\n    stdout:bool=True, # Capture stdout and save as output?\n    stderr:bool=True, # Capture stderr and save as output?\n    timeout:Optional[int]=None, # Shell command will time out after {timeout} seconds\n    verbose:bool=False, # Show stdout/stderr during execution\n):\n\n\nawait s.run_async(\"1+1\")\n\n[{'data': {'text/plain': ['2']},\n  'metadata': {},\n  'output_type': 'execute_result',\n  'execution_count': None}]\n\n\n\nsource\n\n\nrender_outputs\n\ndef render_outputs(\n    outputs, ansi_renderer:function=_strip, include_imgs:bool=True, pygments:bool=False, md_tfm:function=noop,\n    html_tfm:function=noop\n):\n\n\nHTML(render_outputs(o))\n\n---------------------------------------------------------------------------\nTimeoutError                              Traceback (most recent call last)\nFile &lt;ipython-input-1-a5c3817716b6&gt;:1\n----&gt; 1 import time; time.sleep(1.1)\n\nCell In[6], line 7, in run_cell.&lt;locals&gt;.handler(*args)\n----&gt; 7 def handler(*args): raise TimeoutError()\n\nTimeoutError: \n\n\n\nWe can use ansi2html to convert from ANSI to HTML for color rendering. You need some css styles for the colors to render properly. Jupyter already has these built in so it’s not neccessary here, but if you plan on using this in another web app you will need to ensure that css styling is included.\n\nHTML(render_outputs(o, ansi2html))\n\n---------------------------------------------------------------------------\nTimeoutError                              Traceback (most recent call last)\nFile &lt;ipython-input-1-a5c3817716b6&gt;:1\n----&gt; 1 import time; time.sleep(1.1)\n\nCell In[6], line 7, in run_cell.&lt;locals&gt;.handler(*args)\n----&gt; 7 def handler(*args): raise TimeoutError()\n\nTimeoutError: \n\n\n\nImages and matplotlib figures are captured:\n\nres = s.run('''import matplotlib.pyplot as plt\nplt.figure(figsize=(2,1))\nplt.plot([1,2,4]);''')\n\nHTML(render_outputs(res))\n\n\n\n\nIf an exception is raised then the exception type, object, and stacktrace are stored in exc:\n\no = s.run('raise Exception(\"Oops\")')\no\n\n[{'name': 'stdout',\n  'output_type': 'stream',\n  'text': ['\\x1b[31m---------------------------------------------------------------------------\\x1b[39m\\n',\n   '\\x1b[31mException\\x1b[39m                                 Traceback (most recent call last)\\n',\n   '\\x1b[36mFile \\x1b[39m\\x1b[32m&lt;ipython-input-1-01648acb07bd&gt;:1\\x1b[39m\\n',\n   '\\x1b[32m----&gt; \\x1b[39m\\x1b[32m1\\x1b[39m \\x1b[38;5;28;01mraise\\x1b[39;00m \\x1b[38;5;167;01mException\\x1b[39;00m(\\x1b[33m\"\\x1b[39m\\x1b[33mOops\\x1b[39m\\x1b[33m\"\\x1b[39m)\\n',\n   '\\n',\n   '\\x1b[31mException\\x1b[39m: Oops\\n']},\n {'ename': 'Exception',\n  'evalue': 'Oops',\n  'output_type': 'error',\n  'traceback': ['Traceback (most recent call last):\\n',\n   '  File \"/home/radek/miniconda3/envs/kaggle/lib/python3.11/site-packages/IPython/core/interactiveshell.py\", line 3672, in run_code\\n    exec(code_obj, self.user_global_ns, self.user_ns)\\n',\n   '  File \"&lt;ipython-input-1-01648acb07bd&gt;\", line 1, in &lt;module&gt;\\n    raise Exception(\"Oops\")\\n',\n   'Exception: Oops\\n']}]\n\n\n\ns.exc\n\nException('Oops')\n\n\n\nsource\n\n\nCaptureShell.cell\n\ndef cell(\n    cell, stdout:bool=True, stderr:bool=True, verbose:bool=False\n):\n\nRun cell, skipping if not code, and store outputs back in cell\n\nclean = Path('../tests/clean.ipynb')\nnb = read_nb(clean)\nc = nb.cells[1]\nc\n\n{ 'cell_type': 'code',\n  'execution_count': None,\n  'id': 'b123d6d0',\n  'idx_': 1,\n  'metadata': {},\n  'outputs': [],\n  'source': 'print(1)\\n2'}\n\n\n\ns.cell(c)\nc.outputs\n\n[{'name': 'stdout', 'output_type': 'stream', 'text': ['1\\n']},\n {'data': {'text/plain': ['2']},\n  'metadata': {},\n  'output_type': 'execute_result',\n  'execution_count': None}]\n\n\n\nsource\n\n\nfind_output\n\ndef find_output(\n    outp, # Output from `run`\n    ot:str='execute_result', # Output_type to find\n):\n\nFind first output of type ot in CaptureShell.run output\n\nfind_output(c.outputs)['data']\n\n{'text/plain': ['2']}\n\n\n\nfind_output(c.outputs, 'stream')['text']\n\n['1\\n']\n\n\n\nsource\n\n\nout_exec\n\ndef out_exec(\n    outp\n):\n\nGet data from execution result in outp.\n\nout_exec(c.outputs)\n\n'2'\n\n\n\nsource\n\n\nout_stream\n\ndef out_stream(\n    outp\n):\n\nGet text from stream in outp.\n\nout_stream(c.outputs)\n\n'1'\n\n\n\nsource\n\n\nout_error\n\ndef out_error(\n    outp\n):\n\nGet traceback from error in outp.\n\nsource\n\n\nCaptureShell.run_all\n\ndef run_all(\n    nb, # A notebook read with `nbclient` or [`read_nb`](https://AnswerDotAI.github.io/execnb/nbio.html#read_nb)\n    exc_stop:bool=False, # Stop on exceptions?\n    preproc:callable=_false, # Called before each cell is executed\n    postproc:callable=_false, # Called after each cell is executed\n    inject_code:str | None=None, # Code to inject into a cell\n    inject_idx:int=0, # Cell to replace with `inject_code`\n    verbose:bool=False, # Show stdout/stderr during execution\n):\n\nRun all cells in nb, stopping at first exception if exc_stop\n\nnb.cells[2].outputs\n\n[]\n\n\n\ns.run_all(nb)\nnb.cells[2].outputs\n\n[{'data': {'text/plain': ['&lt;IPython.core.display.Markdown object&gt;'],\n   'text/markdown': [\"This is *bold*. Here's a [link](https://www.fast.ai).\"]},\n  'metadata': {},\n  'output_type': 'execute_result',\n  'execution_count': None}]\n\n\nWith exc_stop=False (the default), execution continues after exceptions, and exception details are stored into the appropriate cell’s output:\n\nnb.cells[-1].source\n\n'raise Exception(\"Oopsie!\")'\n\n\n\nnb.cells[-1].outputs\n\n[{'name': 'stdout',\n  'output_type': 'stream',\n  'text': ['\\x1b[31m---------------------------------------------------------------------------\\x1b[39m\\n',\n   '\\x1b[31mException\\x1b[39m                                 Traceback (most recent call last)\\n',\n   '\\x1b[36mFile \\x1b[39m\\x1b[32m&lt;ipython-input-1-1c97c1d317ab&gt;:1\\x1b[39m\\n',\n   '\\x1b[32m----&gt; \\x1b[39m\\x1b[32m1\\x1b[39m \\x1b[38;5;28;01mraise\\x1b[39;00m \\x1b[38;5;167;01mException\\x1b[39;00m(\\x1b[33m\"\\x1b[39m\\x1b[33mOopsie!\\x1b[39m\\x1b[33m\"\\x1b[39m)\\n',\n   '\\n',\n   '\\x1b[31mException\\x1b[39m: Oopsie!\\n']},\n {'ename': 'Exception',\n  'evalue': 'Oopsie!',\n  'output_type': 'error',\n  'traceback': ['Traceback (most recent call last):\\n',\n   '  File \"/home/radek/miniconda3/envs/kaggle/lib/python3.11/site-packages/IPython/core/interactiveshell.py\", line 3672, in run_code\\n    exec(code_obj, self.user_global_ns, self.user_ns)\\n',\n   '  File \"&lt;ipython-input-1-1c97c1d317ab&gt;\", line 1, in &lt;module&gt;\\n    raise Exception(\"Oopsie!\")\\n',\n   'Exception: Oopsie!\\n']}]\n\n\nWith exc_stop=True, exceptions in a cell are raised and no further processing occurs:\n\ntry: s.run_all(nb, exc_stop=True)\nexcept Exception as e: print(f\"got exception: {e}\")\n\ngot exception: Oopsie!\n\n\nWe can pass a function to preproc to have it run on every cell. It can modify the cell as needed. If the function returns True, then that cell will not be executed. For instance, to skip the cell which raises an exception:\n\nnb = read_nb(clean)\ns.run_all(nb, preproc=lambda c: 'raise' in c.source)\n\nThis cell will contain no output, since it was skipped.\n\nnb.cells[-1].outputs\n\n[]\n\n\n\nnb.cells[1].outputs\n\n[{'name': 'stdout', 'output_type': 'stream', 'text': ['1\\n']},\n {'data': {'text/plain': ['2']},\n  'metadata': {},\n  'output_type': 'execute_result',\n  'execution_count': None}]\n\n\nYou can also pass a function to postproc to modify a cell after it is executed.\n\nsource\n\n\nCaptureShell.execute\n\ndef execute(\n    src:str | Path, # Notebook path to read from\n    dest:str | None=None, # Notebook path to write to\n    exc_stop:bool=False, # Stop on exceptions?\n    preproc:callable=_false, # Called before each cell is executed\n    postproc:callable=_false, # Called after each cell is executed\n    inject_code:str | None=None, # Code to inject into a cell\n    inject_path:str | Path | None=None, # Path to file containing code to inject into a cell\n    inject_idx:int=0, # Cell to replace with `inject_code`\n    verbose:bool=False, # Show stdout/stderr during execution\n):\n\nExecute notebook from src and save with outputs to `dest\nThis is a shortcut for the combination of read_nb, CaptureShell.run_all, and write_nb.\n\ns = CaptureShell()\ntry:\n    s.execute(clean, 'tmp.ipynb')\n    print(read_nb('tmp.ipynb').cells[1].outputs)\nfinally: Path('tmp.ipynb').unlink()\n\n[{'name': 'stdout', 'output_type': 'stream', 'text': ['1\\n']}, {'data': {'text/plain': ['2']}, 'execution_count': None, 'metadata': {}, 'output_type': 'execute_result'}]\n\n\n\np = Path.home()/'git'/'fastcore'/'nbs'\nn = p/'03a_parallel.ipynb'\n\n\nsource\n\n\nCaptureShell.prettytb\n\ndef prettytb(\n    fname:str | Path=None, # filename to print alongside the traceback\n):\n\nShow a pretty traceback for notebooks, optionally printing fname.\nIf an error occurs while running a notebook, you can retrieve a pretty version of the error with the prettytb method:\n\ns = CaptureShell()\ntry:\n    s.execute('../tests/error.ipynb', exc_stop=True)\nexcept:\n    print(s.prettytb())\n\nAssertionError in ../tests/error.ipynb:\n===========================================================================\n\nWhile Executing Cell #2:\nTraceback (most recent call last):\n  File \"/tmp/ipykernel_1087357/1421292703.py\", line 3, in &lt;module&gt;\n    s.execute('../tests/error.ipynb', exc_stop=True)\n  File \"/tmp/ipykernel_1087357/3276016238.py\", line 19, in execute\n    self.run_all(nb, exc_stop=exc_stop, preproc=preproc, postproc=postproc,\n  File \"/tmp/ipykernel_1087357/3244179380.py\", line 20, in run_all\n    if self.exc and exc_stop: raise self.exc from None\n                              ^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/home/radek/miniconda3/envs/kaggle/lib/python3.11/site-packages/IPython/core/interactiveshell.py\", line 3672, in run_code\n    exec(code_obj, self.user_global_ns, self.user_ns)\n  File \"&lt;ipython-input-1-b968a57a586e&gt;\", line 3, in &lt;module&gt;\n    foo()\n  File \"/home/radek/workspace/execnb/tests/err.py\", line 2, in foo\n    assert 13 == 98\n           ^^^^^^^^\nAssertionError\n\n\n\n\nIf you pass inject_code to CaptureShell.execute or CaptureShell.run_all, the source of nb.cells[inject_idx] will be replaced with inject_code. By default, the first cell is replaced. For instance consider this notebook:\n\nnb = read_nb('../tests/params.ipynb')\nfor c in nb.cells: print('- ',c.source)\n\n-  a=1\n-  print(a)\n\n\nWe can replace the first cell with a=2 by passing that as inject_code, and the notebook will run with that change:\n\nnb = read_nb('../tests/params.ipynb')\ns.run_all(nb, inject_code=\"a=2\")\nlist(nb.cells)\n\n[{'cell_type': 'code',\n  'execution_count': None,\n  'id': 'a63ce885',\n  'metadata': {},\n  'outputs': [],\n  'source': 'a=2',\n  'idx_': 0},\n {'cell_type': 'code',\n  'execution_count': None,\n  'id': 'ea528db5',\n  'metadata': {},\n  'outputs': [{'name': 'stdout', 'output_type': 'stream', 'text': ['2\\n']}],\n  'source': 'print(a)',\n  'idx_': 1}]\n\n\nThis can be used with CaptureShell.execute to parameterise runs of models in notebooks. Place any defaults for configuration code needed in the first cell, and then when running execute pass in new parameters as needed in inject_code. To replace only some of the defaults, leave an empty cell as the second cell, and inject code using inject_idx=1 to replace the empty second cell with code that overrides some of the defaults set in the first cell. When using execute you can pass inject_path instead of inject_code to read the injected code from a file.\n\nsource\n\n\nexec_nb\n\ndef exec_nb(\n    src:str, # Notebook path to read from\n    dest:str='', # Notebook path to write to\n    exc_stop:bool=False, # Stop on exceptions?\n    inject_code:str=None, # Code to inject into a cell\n    inject_path:str=None, # Path to file containing code to inject into a cell\n    inject_idx:int=0, # Cell to replace with `inject_code`\n    verbose:bool=False, # Show stdout/stderr during execution\n):\n\nExecute notebook from src and save with outputs to dest\nThis is the command-line version of CaptureShell.execute. Run exec_nb -h from the command line to see how to pass arguments. If you don’t pass dest then the output notebook won’t be saved; this is mainly useful for running tests.\n\nsource\n\n\nSmartCompleter\n\ndef SmartCompleter(\n    shell, # a pointer to the ipython shell itself.  This is needed\nbecause this completer knows about magic functions, and those can\nonly be accessed via the ipython instance.\n    namespace:NoneType=None, # an optional dict where completions are performed.\n    jedi:bool=False\n):\n\nExtension of the completer class with IPython-specific features\n\ncc = SmartCompleter(get_ipython())\n\ndef test_set(a,b): return test_eq(set(a), set(b))\n\nclass _f:\n    def __init__(self): self.bar,self.baz,self.room = 0,0,0\n\nfoo = _f()\n\nassert set(cc(\"b\")).issuperset(['bool', 'bytes'])\ntest_set(cc(\"foo.b\"), ['bar', 'baz'])\ntest_set(cc(\"x=1; x = foo.b\"), ['bar', 'baz'])\ntest_set(cc(\"ab\"), ['abs'])\ntest_set(cc(\"b = ab\"), ['abs'])\ntest_set(cc(\"\"), [])\ntest_set(cc(\"foo.\"), ['bar', 'baz', 'room'])\ntest_set(cc(\"nonexistent.b\"), [])\ntest_set(cc(\"foo.nonexistent.b\"), [])\nassert set(cc(\"import ab\")).issuperset(['abc'])\ntest_set(cc(\"from abc import AB\"), ['ABC', 'ABCMeta'])\n\n\ns = CaptureShell()\ncc = SmartCompleter(s)\ns.run('''def captures(pat, s, n, **kw):\n    return 1''')\ncc('captures(')\n\n['n=', 'pat=', 's=']\n\n\n\nsource\n\n\nCaptureShell.complete\n\ndef complete(\n    c\n): # The actual text that was completed.\n\nReturn the completed text and a list of completions.\n\ns = CaptureShell()\ns.run('a=1')\ns.complete('a.b')\n\n['bit_count', 'bit_length']\n\n\n\ns.run('import re')\ns.complete('re.compile(')\n\n['flags=', 'pattern=']",
    "crumbs": [
      "shell"
    ]
  },
  {
    "objectID": "nbio.html",
    "href": "nbio.html",
    "title": "nbio",
    "section": "",
    "text": "A notebook is just a json file.\n\n\nExported source\ndef _read_json(self, encoding=None, errors=None):\n    return loads(Path(self).read_text(encoding=encoding, errors=errors))\n\n\n\nminimal_fn = Path('../tests/minimal.ipynb')\nminimal_txt = AttrDict(_read_json(minimal_fn))\n\nIt contains two sections, the metadata…:\n\nminimal_txt.metadata\n\n{'solveit_dialog_mode': 'learning', 'solveit_ver': 2}\n\n\n…and, more importantly, the cells:\n\nminimal_txt.cells\n\n[{'cell_type': 'markdown',\n  'id': '801558df',\n  'metadata': {},\n  'source': ['## A minimal notebook']},\n {'cell_type': 'code',\n  'execution_count': None,\n  'id': 'e2147a69',\n  'metadata': {'time_run': '2026-01-04T20:52:49.901559+00:00'},\n  'outputs': [{'data': {'text/plain': ['2']},\n    'execution_count': 0,\n    'metadata': {},\n    'output_type': 'execute_result'}],\n  'source': ['# Do some arithmetic\\n', '1+1']}]\n\n\nThe second cell here is a code cell, however it contains no outputs, because it hasn’t been executed yet. To execute a notebook, we first need to convert it into a format suitable for nbclient (which expects some dict keys to be available as attrs, and some available as regular dict keys). Normally, nbformat is used for this step, but it’s rather slow and inflexible, so we’ll write our own function based on fastcore’s handy dict2obj, which makes all keys available as both attrs and keys.\n\nsource\n\n\n\ndef NbCell(\n    idx, cell\n):\n\ndict subclass that also provides access to keys as attrs\nWe use an AttrDict subclass which has some basic functionality for accessing notebook cells.\n\nsource\n\n\n\n\ndef dict2nb(\n    js:NoneType=None, kwargs:VAR_KEYWORD\n):\n\nConvert dict js to an AttrDict,\nWe can now convert our JSON into this nbclient-compatible format, which pretty prints the source code of cells in notebooks.\n\nminimal = dict2nb(minimal_txt)\ncell = minimal.cells[1]\ncell\n\n{ 'cell_type': 'code',\n  'execution_count': None,\n  'id': 'e2147a69',\n  'idx_': 1,\n  'metadata': {'time_run': '2026-01-04T20:52:49.901559+00:00'},\n  'outputs': [ { 'data': {'text/plain': ['2']},\n                 'execution_count': 0,\n                 'metadata': {},\n                 'output_type': 'execute_result'}],\n  'source': '# Do some arithmetic\\n1+1'}\n\n\nThe abstract syntax tree of source code cells is available in the parsed_ property:\n\ncell.parsed_(), cell.parsed_()[0].value.op\n\n([&lt;ast.Expr&gt;], &lt;ast.Add&gt;)\n\n\n\nsource\n\n\n\n\ndef read_nb(\n    path\n):\n\nReturn notebook at path\nThis reads the JSON for the file at path and converts it with dict2nb. For instance:\n\nminimal = read_nb(minimal_fn)\nstr(minimal.cells[0])\n\n\"{'cell_type': 'markdown', 'id': '801558df', 'metadata': {}, 'source': '## A minimal notebook', 'idx_': 0}\"\n\n\nThe file name read is stored in path_:\n\nminimal.path_\n\n'../tests/minimal.ipynb'",
    "crumbs": [
      "nbio"
    ]
  },
  {
    "objectID": "nbio.html#reading-a-notebook",
    "href": "nbio.html#reading-a-notebook",
    "title": "nbio",
    "section": "",
    "text": "A notebook is just a json file.\n\n\nExported source\ndef _read_json(self, encoding=None, errors=None):\n    return loads(Path(self).read_text(encoding=encoding, errors=errors))\n\n\n\nminimal_fn = Path('../tests/minimal.ipynb')\nminimal_txt = AttrDict(_read_json(minimal_fn))\n\nIt contains two sections, the metadata…:\n\nminimal_txt.metadata\n\n{'solveit_dialog_mode': 'learning', 'solveit_ver': 2}\n\n\n…and, more importantly, the cells:\n\nminimal_txt.cells\n\n[{'cell_type': 'markdown',\n  'id': '801558df',\n  'metadata': {},\n  'source': ['## A minimal notebook']},\n {'cell_type': 'code',\n  'execution_count': None,\n  'id': 'e2147a69',\n  'metadata': {'time_run': '2026-01-04T20:52:49.901559+00:00'},\n  'outputs': [{'data': {'text/plain': ['2']},\n    'execution_count': 0,\n    'metadata': {},\n    'output_type': 'execute_result'}],\n  'source': ['# Do some arithmetic\\n', '1+1']}]\n\n\nThe second cell here is a code cell, however it contains no outputs, because it hasn’t been executed yet. To execute a notebook, we first need to convert it into a format suitable for nbclient (which expects some dict keys to be available as attrs, and some available as regular dict keys). Normally, nbformat is used for this step, but it’s rather slow and inflexible, so we’ll write our own function based on fastcore’s handy dict2obj, which makes all keys available as both attrs and keys.\n\nsource\n\n\n\ndef NbCell(\n    idx, cell\n):\n\ndict subclass that also provides access to keys as attrs\nWe use an AttrDict subclass which has some basic functionality for accessing notebook cells.\n\nsource\n\n\n\n\ndef dict2nb(\n    js:NoneType=None, kwargs:VAR_KEYWORD\n):\n\nConvert dict js to an AttrDict,\nWe can now convert our JSON into this nbclient-compatible format, which pretty prints the source code of cells in notebooks.\n\nminimal = dict2nb(minimal_txt)\ncell = minimal.cells[1]\ncell\n\n{ 'cell_type': 'code',\n  'execution_count': None,\n  'id': 'e2147a69',\n  'idx_': 1,\n  'metadata': {'time_run': '2026-01-04T20:52:49.901559+00:00'},\n  'outputs': [ { 'data': {'text/plain': ['2']},\n                 'execution_count': 0,\n                 'metadata': {},\n                 'output_type': 'execute_result'}],\n  'source': '# Do some arithmetic\\n1+1'}\n\n\nThe abstract syntax tree of source code cells is available in the parsed_ property:\n\ncell.parsed_(), cell.parsed_()[0].value.op\n\n([&lt;ast.Expr&gt;], &lt;ast.Add&gt;)\n\n\n\nsource\n\n\n\n\ndef read_nb(\n    path\n):\n\nReturn notebook at path\nThis reads the JSON for the file at path and converts it with dict2nb. For instance:\n\nminimal = read_nb(minimal_fn)\nstr(minimal.cells[0])\n\n\"{'cell_type': 'markdown', 'id': '801558df', 'metadata': {}, 'source': '## A minimal notebook', 'idx_': 0}\"\n\n\nThe file name read is stored in path_:\n\nminimal.path_\n\n'../tests/minimal.ipynb'",
    "crumbs": [
      "nbio"
    ]
  },
  {
    "objectID": "nbio.html#creating-a-notebook",
    "href": "nbio.html#creating-a-notebook",
    "title": "nbio",
    "section": "Creating a notebook",
    "text": "Creating a notebook\n\nsource\n\nmk_cell\n\ndef mk_cell(\n    text, # `source` attr in cell\n    cell_type:str='code', # `cell_type` attr in cell\n    kwargs:VAR_KEYWORD\n):\n\nCreate an NbCell containing text\n\nmk_cell('print(1)', execution_count=0)\n\n{ 'cell_type': 'code',\n  'directives_': {},\n  'execution_count': 0,\n  'id': 'f6ddf5a3',\n  'idx_': 0,\n  'metadata': {},\n  'outputs': [],\n  'source': 'print(1)'}\n\n\n\nsource\n\n\nnew_nb\n\ndef new_nb(\n    cells:NoneType=None, meta:NoneType=None, nbformat:int=4, nbformat_minor:int=5\n):\n\nReturns an empty new notebook\nUse this function when creating a new notebook. Useful for when you don’t want to create a notebook on disk first and then read it.",
    "crumbs": [
      "nbio"
    ]
  },
  {
    "objectID": "nbio.html#writing-a-notebook",
    "href": "nbio.html#writing-a-notebook",
    "title": "nbio",
    "section": "Writing a notebook",
    "text": "Writing a notebook\n\nsource\n\nnb2dict\n\ndef nb2dict(\n    d, k:NoneType=None\n):\n\nConvert parsed notebook to dict\nThis returns the exact same dict as is read from the notebook JSON.\n\nminimal_fn = Path('../tests/minimal.ipynb')\nminimal = read_nb(minimal_fn)\nminimal_dict = _read_json(minimal_fn)\nassert minimal_dict==nb2dict(minimal)\n\n\nsource\n\n\nnb2str\n\ndef nb2str(\n    nb\n):\n\nConvert nb to a str\nTo save a notebook we first need to convert it to a str:\n\nprint(nb2str(minimal)[:45])\n\n{\n \"cells\": [\n  {\n   \"cell_type\": \"markdown\",\n\n\n\nsource\n\n\nwrite_nb\n\ndef write_nb(\n    nb, path\n):\n\nWrite nb to path\nThis returns the exact same string as saved by Jupyter.\n\ntmp = Path('tmp.ipynb')\ntry:\n    minimal_txt = minimal_fn.read_text()\n    write_nb(minimal, tmp)\n    test_eq(minimal_txt, tmp.read_text())\nfinally: tmp.unlink()\n\nHere’s how to put all the pieces of execnb.nbio together:\n\nnb = new_nb([mk_cell('print(1)')])\npath = Path('test.ipynb')\nwrite_nb(nb, path)\nnb2 = read_nb(path)\nprint(nb2.cells)\npath.unlink()\n\n[{'cell_type': 'code', 'execution_count': 0, 'id': '5e7ed95f', 'metadata': {}, 'outputs': [], 'source': 'print(1)', 'idx_': 0}]",
    "crumbs": [
      "nbio"
    ]
  }
]